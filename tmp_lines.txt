1	import argparse1	import os1	import time1	from pathlib import Path1	from typing import List1	1	import yaml1	from dotenv import load_dotenv1	1	from langchain_community.document_loaders import TextLoader1	from langchain_community.document_loaders import PyMuPDFLoader, PyPDFLoader, PyPDFium2Loader, PDFPlumberLoader1	from langchain_pymupdf4llm import PyMuPDF4LLMLoader1	from langchain_text_splitters import RecursiveCharacterTextSplitter1	from langchain_openai import OpenAIEmbeddings1	from langchain_community.vectorstores import FAISS1	1	def load_settings(settings_path: Path) -> dict:1	    if settings_path.exists():1	        with settings_path.open("r", encoding="utf-8") as f:1	            return yaml.safe_load(f) or {}1	    return {}1	1	1	def pdfloader(r_tool: str, input_path: Path):1	    """PDF 繝ｭ繝ｼ繝繝ｼ繧定ｿ斐☆縲る∈謚櫁い縺ｯ莉･荳九・騾壹ｊ縲・    - pymupdf: PyMuPDF (fitz) 繝吶・繧ｹ縺ｮ繝ｭ繝ｼ繝繝ｼ1	    - pymupdf4llm: PyMuPDF4LLM 繝吶・繧ｹ縺ｮ繝ｭ繝ｼ繝繝ｼ1	    - pypdf: PyPDF2 繝吶・繧ｹ縺ｮ繝ｭ繝ｼ繝繝ｼ1	    - pdfplumber: pdfplumber 繝吶・繧ｹ縺ｮ繝ｭ繝ｼ繝繝ｼ1	    - auto: pymupdf -> pypdf -> pdfplumber 縺ｮ鬆・〒隧ｦ1	    螟ｱ謨励＠縺溷ｴ蜷医・萓句､悶ｒ謚輔£繧九・    """1	    try:1	        if r_tool == "pymupdf":1	            return PyMuPDFLoader(str(input_path))1	        elif r_tool == "pymupdf4llm":1	            return PyMuPDF4LLMLoader(str(input_path))1	        elif r_tool == "pypdf":1	            return PyPDFLoader(str(input_path))1	        elif r_tool == "pdfium2":1	            return PyPDFium2Loader(str(input_path))1	        elif r_tool == "pdfplumber":1	            return PDFPlumberLoader(str(input_path))1	    except Exception as e:1	        raise ValueError(f"Unknown reading_tool: {r_tool}")1	1	1	1	def collect_documents(r_tool: str, input_path: Path) -> List:1	    """1	    Collect Markdown,txt or pdf documents from a file or directory.1	    - If file: supports .md/.markdown/.txt or .pdf1	    - If directory: scans for .md/.markdown/.txt or .pdf recursively1	    """1	    docs = []1	    targets: List[Path] = []1	    if input_path.is_file():1	        targets = [input_path]1	    else:1	        targets = (1	            sorted(input_path.glob("**/*.md"))1	            + sorted(input_path.glob("**/*.markdown"))1	            + sorted(input_path.glob("**/*.txt"))1	            + sorted(input_path.glob("**/*.pdf"))1	        )1	1	    for p in targets:1	        try:1	            if p.suffix.lower() in {".md", ".markdown", ".txt"}:1	                loader = TextLoader(str(p), encoding="utf-8")1	                docs.extend(loader.load())1	1	            elif p.suffix.lower() in {".pdf"}:1	                loader = pdfloader(r_tool, p)1	                docs.extend(loader.load())1	            else:1	                print(f"Warning: unsupported file type {p}, skipping")1	1	        except Exception as e:1	            print(f"Warning: failed to load {p}: {e}")1	    return docs1	1	1	def main():1	    t0 = time.perf_counter()1	    parser = argparse.ArgumentParser(description="Build FAISS index from Markdown, txt or pdf sources under llm/")1	    parser.add_argument("--input", default="llm", help="Path to a file or directory containing .md/.txt/.pdf")1	    parser.add_argument("--out", default="artifacts", help="Output directory for FAISS index")1	    parser.add_argument("--chunk_size", type=int, default=800, help="Chunk size in characters")1	    parser.add_argument("--chunk_overlap", type=int, default=200, help="Chunk overlap in characters")1	    parser.add_argument("--model", default="text-embedding-3-small", help="OpenAI embeddings model")1	    parser.add_argument("--peek", type=int, default=0, help="Print first N chunks for inspection")1	    parser.add_argument(1	        "--reading_tool",1	        default="pymupdf",1	        choices=[1	            "pymupdf",1	            "pymupdf4llm",1	            "pypdf",1	            "pdfplumber",1	            "pdfium2",1	            "docling",1	            "auto",1	        ],1	        help="PDF reader to use (pymupdf/pymupdf4llm/pypdf/pdfplumber/pdfium/docling/auto)",1	    )1	    args = parser.parse_args()1	1	    # Load environment from .env and .env.local (latter overrides)1	    load_dotenv(dotenv_path=Path(".env"))1	    load_dotenv(dotenv_path=Path(".env.local"), override=True)1	1	    input_path = Path(args.input)1	1	    if not input_path.exists():1	        print(f"Error: input path {input_path} does not exist")1	        return1	1	    out_dir = Path(args.out)1	1	    out_dir.mkdir(parents=True, exist_ok=True)1	1	    _ = load_settings(Path("config/settings.yml"))1	1	    r_tool = args.reading_tool1	1	    # Collect1	    documents = collect_documents(r_tool, input_path)1	    if not documents:1	        print(f"No source files found under {input_path}. Place .md/.txt/.pdf and rerun.")1	        return1	1	    # split1	    splitter = RecursiveCharacterTextSplitter(1	        chunk_size=args.chunk_size,1	        chunk_overlap=args.chunk_overlap,1	        separators=["\n\n", "\n", "縲・, "縲・, " "]1	    )1	    splits = splitter.split_documents(documents)1	    print(f"Loaded {len(documents)} pages -> {len(splits)} chunks")1	    if not splits:1	        total_chars = sum(len((d.page_content or "")) for d in documents)1	        print(1	            "No text chunks produced. Details:"1	            f" documents={len(documents)}, total_chars={total_chars},"1	            f" chunk_size={args.chunk_size}, chunk_overlap={args.chunk_overlap}"1	        )1	        print(1	            "Check that your Markdown files exist and have content.\n"1	            "If running via Docker, ensure the llm/ folder is mounted."1	        )1	        return1	    if args.peek > 0:1	        print("--- Peek chunks ---")1	        for i, d in enumerate(splits[: args.peek]):1	            txt = (d.page_content or "").replace("\n", " ")1	            print(f"[{i+1}] {txt[:200]}")1	1	    # Embeddings + FAISS1	    if not os.getenv("OPENAI_API_KEY"):1	        raise RuntimeError("OPENAI_API_KEY is not set. Put it in .env.local or .env")1	    embeddings = OpenAIEmbeddings(model=args.model)1	    vectordb = FAISS.from_documents(splits, embeddings)1	1	    # Save1	    vectordb.save_local(str(out_dir))1	    print(f"Saved FAISS index to {out_dir}")1	    print(f"total_index_time_sec={time.perf_counter()-t0:.2f}")1	1	1	if __name__ == "__main__":1	    main()